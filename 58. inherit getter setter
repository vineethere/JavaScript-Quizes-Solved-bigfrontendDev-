
// https://bigfrontend.dev/quiz/inherit-getter-setter

// This is a JavaScript Quiz from BFE.dev

let val = 0

class A {
  set foo(_val) {
    val = _val
  }
  get foo() {
    return val
  }
}

class B extends A { }

class C extends A {
  get foo() {
    return val
  }
}

const b = new B()
console.log(b.foo)
b.foo = 1
console.log(b.foo)

const c = new C()
console.log(c.foo)
c.foo = 2
console.log(c.foo)
console.log(b.foo)







// Key Concepts:
// JavaScript getter/setter pairs must be defined together if you want both to work. If a class overrides just the getter or just the setter, it replaces the whole property and the other part is lost.

// When a class like C overrides only the getter, the inherited setter from A is not accessible anymore.

// Assigning to a property with only a getter (and no setter) results in no effect. In strict mode, this may even throw an error. In normal mode, it silently fails.

// If a getter exists but no setter, doing obj.prop = value does not call any function and does not create an own property either â€“ the assignment is ignored.

// All foo accesses in the classes deal with a shared external variable val. Changing val via a setter affects all classes that rely on the getter.

// Line-by-line Behavior:
// b = new B() creates an instance of B, which inherits both getter and setter from A.

// console.log(b.foo) returns 0 (initial value of val).

// b.foo = 1 updates val to 1 via setter from A.

// console.log(b.foo) returns 1.

// c = new C() creates an instance of C with its own getter but no setter.

// console.log(c.foo) returns 1 (current val).

// c.foo = 2 is ignored because C has no setter, and the inherited setter was shadowed by the new getter.

// console.log(c.foo) returns 1 (value of val unchanged).

// console.log(b.foo) returns 1 (still the current val).

// Final Output:

// 0
// 1
// 1
// 1
// 1

// Solution:
// 0
// 1
// 1
// 1
// 1
