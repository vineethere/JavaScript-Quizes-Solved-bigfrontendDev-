// https://bigfrontend.dev/quiz/instanceOf

console.log(typeof null)
console.log(null instanceof Object) 
console.log(typeof 1)
console.log(1 instanceof Number)
console.log(1 instanceof Object)
console.log(Number(1) instanceof Object)
console.log(new Number(1) instanceof Object)
console.log(typeof true)
console.log(true instanceof Boolean)
console.log(true instanceof Object)
console.log(Boolean(true) instanceof Object)
console.log(new Boolean(true) instanceof Object)
console.log([] instanceof Array)
console.log([] instanceof Object)
console.log((() => {}) instanceof Object)



// console.log(typeof null)
// Output: "object"

// Explanation: This is a well-known JavaScript quirk/bug. Even though null is a primitive value representing "no value" or "empty", the typeof operator returns "object". This behavior is legacy from early JavaScript implementations and has never been fixed to avoid breaking existing code.

//  console.log(null instanceof Object)
// Output: false

// Explanation: The instanceof operator checks the prototype chain to see if the left operand inherits from the right operand's prototype. Since null has no prototype (it's not an object, it's a primitive), this check returns false.

//  console.log(instanceof Number)
// Output: false

// Explanation: The instanceof operator checks if the left operand is an object that inherits from Number.prototype. But 1 is a primitive number, not an object. So this returns false.
// const numObj = new Number(1);
// console.log(numObj instanceof Number);  // true



// Output:
// object
// false
// number
// false
// false
// false
// true
// boolean
// false
// false
// false
// true
// true
// true
// true
