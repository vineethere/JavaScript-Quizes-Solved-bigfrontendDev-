// https://bigfrontend.dev/quiz/iterable

const entries = [1,2,3,4].entries()
for (const [, item] of entries) {
  console.log(item)
  break;
}
for (const [, item] of entries) {
  console.log(item)
  break;
}


// Understanding JavaScript Iterators and Loops
// What is an Iterator?

// Iterators are objects that implement the iterator protocol. They return an object with two properties when you call .next():

// value: The next value in the sequence.

// done: A boolean indicating whether the sequence has been exhausted.

// Iterators remember the position they are at in the sequence, and each .next() call moves them forward.

// How .entries() Works

// .entries() returns an iterator for an array, which yields [index, value] pairs.

// Stateful: The iterator keeps track of the current position. Once it yields a value, it moves forward and doesn't reset unless you explicitly recreate the iterator.

// Key Concept: Iterators Are Consumed

// An iterator is consumed as you loop over it. Once you call .next() and retrieve a value, the iterator "remembers" where it left off.

// If you use an iterator in one loop and then use it again in another, it does not start from the beginning unless you create a new iterator.

// Code Example Explanation
// const entries = [1, 2, 3, 4].entries();

// for (const [, item] of entries) {
//   console.log(item);
//   break;
// }

// for (const [, item] of entries) {
//   console.log(item);
//   break;
// }


// First Loop:

// The iterator entries starts at [0, 1].

// Logs 1, then break ends the loop.

// Second Loop:

// The iterator entries picks up where the first left off. It’s now at [1, 2] (since the first loop already advanced it).

// Logs 2, then break ends the loop.

// Why Does This Happen?

// Iterators don’t reset: They maintain their state (position in the sequence). This is why the second loop logs 2, not 1.

// JavaScript’s design: Iterators are meant to be used once. To reset or re-use an iterator, you need to create a new one.

// How to Reset an Iterator

// If you want both loops to start fresh, you have to call .entries() again:

// for (const [, item] of [1, 2, 3, 4].entries()) {
//   console.log(item);
//   break;
// }

// for (const [, item] of [1, 2, 3, 4].entries()) {
//   console.log(item);
//   break;
// }


// This creates two separate iterators and both will start from the beginning.

// Summary of Key Points

// Iterators are stateful and do not reset automatically.

// Once an iterator has been consumed, it remembers its position. If you want to reuse it, you need to create a new iterator by calling .entries() again.

// The reason the second loop logs 2 instead of 1 is because it continues from the current state of the iterator, not from the start.

// If you want to make the loops behave independently, create a fresh iterator for each one.

// This should give you a good grasp of how JavaScript iterators work in loops. Let me know if you need anything else clarified or if you'd like more examples!

//Solution
// 1
// 2
